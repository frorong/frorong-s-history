---
id: 2
title: 왜 translate를 사용해야 할까? 브라우저 렌더링 과정!
description: 브라우저 렌더링 과정에 대해 알아보고 그 속에서 translate를 사용해야 하는 이유를 도출합시다.
date: '2023-11-13'
category: CS
---

# \[CSS, CS\] 왜 translate를 사용해야 할까? 브라우저 렌더링 과정!

우리가 css 속성으로 애니메이션을 구현할 때에는 translate를 사용하라고 한다. 왜 때문일까? left나 right 속성으로 위치를 조정할 수도 있을 텐데 말이다. 그걸 이해하기 위해선 먼저 브라우저 렌더링 과정을 알아야 한다.

## 브라우저 렌더링 과정

사용자가 웹 서비스에 접속하려면 브라우저가 사용자가 요청한 웹 페이지를 서버에 요청하여 서버에서 보내준 응답을 화면에 그려줘야한다. 상세한 과정은 다음과 같다.
<br/>

브라우저가 사용자가 접속할 주소로 네트워크 요청을 보내고 이 요청은 도메인과 IP를 매핑 해놓은 서버인 DNS 서버에 들려진다. 브라우저가 요청을 하면 DNS 서버에서 DNS 조회, 인증 과정 이후에 접속할 주소에 해당하는 웹서버와 연결이 된다. 서버는 브라우저 렌더링에 필요한 리소스를 반환한다.
<br/>

서버가 리소스를 반환하는 과정에서는 혼잡을 피하기 위해 점진적으로 패킷의 사이즈를 늘리는 TCP slow start와, 서버의 전송 속도를 결정하기 위해 확인 응답을 보내는 혼잡 제어 과정이 포함되어 있다.
<br/>

렌더링 엔진이 리소스를 해석하여 브라우저가 해석할 수 있는 DOM 트리를 생성하고 이 과정을 html 파싱이라고 한다.
<br/>

html을 파싱 하는 도중 css 파일을 로드하는 태그를 만나면 css 파일을 서버에 요청하고, css  파일을 파싱 하여 CSSOM 트리를 구축한다. html은 로드되었는데 style이 적용되지 않는 경우를 방지하기 위해선 style 태그나 link태그를 html 상단에 위치시켜 빠르게 파싱 할 수 있도록 해야 한다. 이 부분이 프리로드 스캐너이다.
<br/>

만약 style 태그나 link 태그가 아닌 script 태그를 만나면 html 파싱을 중단하고 스크립트를 다운로드한다. 스크립트가 로딩되면 javascript 엔진이 스크립트를 실행하고, 과정이 종료되면 다시 html 파싱이 중단된 부분으로 돌아와 파싱을 계속한다. 이런 이유 때문에 script 태그를 사용할 때에는 defer나 async속성을 사용하거나 하단에 배치해야 한다. async 속성은 스크립트 실행과 html 파싱이 동시에 이루어질 수 있어, html 파싱이 모두 끝난 이후에 실행되는 defer 속성이 더 안전하다.
<br/>

렌더링 엔진은 DOM 트리와 CSSOM 트리를 합쳐 렌더 트리를 만든다. 이 렌더 트리를 기반으로 element들의 모양, 크기, 위치를 계산하는 layout이라는 프로세스를 거친다. 레이아웃은 일반적으로 박스 모델 속성을 통해 element의 크기를 계산한다.
<br/>

처음 요소의 사이즈와 위치를 결정하는 것을 레이아웃이라 하고, 이후에 요소의 사이즈나 위치를 다시 계산하는 것을 리플로우라고 한다. 리플로우는 레이아웃 이후에 있는 페이지의 일부나 전체의 크기 위치 등의 설정이다.
<br/>

각 요소를 화면에 그리는 것을 페인팅이라고 한다. 페인팅은 레이아웃 트리의 요소를 레이어로 분리할 수 있다. 레이어는 화면의 일부를 독립적으로 그릴 수 있는 구조이다. 컨텐츠를 CPU의 메인 스레드에서 GPU로 격상하며 페인트 및 리페인트 성능을 올리게 된다.
<br/>

문서의 각 섹션이 다른 레이어에서 그려져 섹션이 겹쳐짐에 따라 정확한 렌더링을 보장하기 위한 합성이 필요하다. 리플로우가 일어나면 리페인트와 재합성까지 일어나게 된다.
<br/>

메인 스레드가 페이지를 모두 그려냈다면 상호작용이 준비가 될 때까지 시간이 필요하다. 그 시간의 단위를 TTI라고 한다.
<br/>

정리하자면 다음과 같다.
<br/>

**1\. 브라우저의 요청이 DNS 서버를 거친 후 서버에게 리소스를 요청한다.**
<br/>

**2\. 서버가 리소스를 응답해 준다.**
<br/>

**3\. html과 css는 렌더링 엔진에 의해 파싱 되고, javascript는 컴파일 및 실행된다.**
<br/>

**4\. 렌더링 엔진이 렌더 트리를 만들고, 이를 기반으로 화면에 페인팅한다.**
<br/>

**5\. 사용자와의 상호작용을 준비한다.**
<br/>

자 이제 브라우저가 어떻게 렌더링 하는지 원리는 알겠는데 이게 translate와는 무슨 관계인 걸까?
<br/>

## Reflow와 translate

브라우저의 렌더링 원리와 translate의 관계를 알기 위해선 렌더링 과정 중 리플로우에 초점을 둬야 한다.
<br/>

위에서 설명했듯 레이아웃 이후에 요소의 크기나 위치를 재정의 하는 것을 리플로우라고 한다. 리플로우 이후에 리페인트와 재합성이 일어나므로 리플로우가 자주 발생하면 브라우저 렌더링 성능이 떨어지고 사용자 경험에 안 좋은 영향을 끼친다.
<br/>

이를 해결하기 위해서 직접 요소의 절대적인 위치를 바꾸는 left나 right속성이 아닌, translate를 사용해야 한다. left나 right속성은 요소의 레이아웃을 변경하므로 reflow와 repaint를 일으키지만, translate는 레이아웃을 건드리지 않고 단순히 요소의 시각적 모양만 변경하기 때문에 리플로우를 일으키지 않는다. 다만 시각적 모양이 변경되기 때문에 repaint는 발생할 수 있다.
<br/>

이렇게 리플로우가 발생하지 않는 속성은 translate를 포함한 transform의 속성들, color, opacity 등이 있다. 이러한 속성들은 주로 GPU를 활용하여 처리된다.
<br/>

## 마치며

개인적으로 브라우저 렌더링 원리에 대한 개념적 부분이 아쉬웠는데, 블로그를 작성하며 개념을 좀 더 확립할 수 있었다. 덤으로, 크롬 개발자 도구를 사용하여 이벤트 로그와 리페인트가 어떻게 발생하는지 확인할 수 있다. 이러한 개념과 도구를 활용하여 테스트를 진행하면 보다 흥미로운 결과를 얻을 수 있을 것으로 생각된다.

## Reference

[developer.mozilla.org](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work#%EA%B5%AC%EB%AC%B8_%EB%B6%84%EC%84%9Dparsing)
